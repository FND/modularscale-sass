// Stripping units is not a best practice
// This function should not be used elsewhere
// It is used here because calc() doesn't do unit logic
@function ms-unitless($val) {
  $val: $val / ($val - $val + 1);
  @return $val;
}

// Generate calc() function
@function ms-fluid($val1: 1em, $val2: 1em, $break1: 0, $break2: 0) {
  $diff: ms-unitless($val2) - ms-unitless($val1);
  @return calc( #{$val1} + #{ms-unitless($val2) - ms-unitless($val1)} * ( ( 100vw - #{$break1}) / #{ms-unitless($break2) - ms-unitless($break1)} ) );
}

// Main responsive mixin
@mixin ms-respond($prop, $val, $map: $modularscale) {
  $base: $ms-base;
  $ratio: $ms-ratio;

  $first-write: true;
  $last-break: null;

  // loop through all settings with a breakpoint type value
  @each $v, $s in $map {
    @if type-of($v) == number {
      @if unit($v) != '' {

        @if $first-write {
          #{$prop}: ms-function($val, $thread: $v, $settings: $map);
          $first-write: false;
          $last-break: $v;
        }
        @else {
          @media (min-width: $last-break) and (max-width: $v) {
            $val1: ms-function($val, $thread: $last-break, $settings: $map);
            $val2: ms-function($val, $thread: $v, $settings: $map);
            #{$prop}: ms-fluid($val1,$val2,$last-break,$v);
          }
          $last-break: $v;
        }
        @debug unit($v);
        @debug $v $s;
      }
    }
  }
  @if $last-break {
    @media (min-width: $last-break) {
      #{$prop}: ms-function($val, $thread: $last-break, $settings: $map);
    }
  }
}

foo {
  bar: baz;
}