@function modular-scale($s,$b,$r) {

  // Fast calc if not multi stranded
  @if(length($b) == 1) {
    @return pow($r, $s) * $b;
  }

  // Create new base array
  $bases: nth($b,1);

  // Normalize base values
  @for $i from 2 through length($b) {
    // initial base value
    $base: nth($b,$i);
    // If the base is bigger than the main base
    @if($base > nth($b,1)) {
      // divide the value until it aligns with main base.
      @while($base > nth($b,1)) {
        $base: $base / $r;
      }
      $base: $base * $r;
    }
    // If the base is smaller than the main base.
    @elseif ($base < nth($b,1)) {
      // pump up the value until it aligns with main base.
      @while $base < nth($b,1) {
        $base: $base * $r;
      }
    }
    // Push into new array
    $bases: append($bases,$base);
  }

  // Sort array from smallest to largest.
  // bases = bases.sort();

  // Find step to use in calculation
  $step: floor($s / length($bases));
  // Find base to use in calculation
  $base: round(($s / length($bases) - $step) * length($bases)) + 1;

  @return pow($r, $step) * nth($bases,$base);
}